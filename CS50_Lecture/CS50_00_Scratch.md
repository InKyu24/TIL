# CS50_2020_00_Scratch

## Representation

여기는 CS50, 컴퓨터 공학의 지적 사업과 프로그래밍 기술에 대한 하버드 대학교의 입문 수업입니다. 보통 우리는 샌더스 극장에서 함께하고 있을테지만 여러 가지 이유들로 인해 올해는 조금 다르게 로브 드라마 센터에 있어요. 협력해 준 친구들 덕분에 우리는 여기 무대 뒤쪽 소품 시설들을 포함한 새로운 장소에 있게 되었습니다. 이번 학기 그리고 CS50을 준비하기 위해 올 여름 동안 놀랍도록 재능있는 팀과 함께했죠. 그래서 우리는 그 과정에서 새롭고 개선된 설명을 할 것이라고 감히 말할 수 있겠네요.

우리는 캠퍼스 자체의 기억 또는 이미지를 불러 일으키고 싶어요. 특히 이번 학기에 직접 이 장소에 올 수 없었던 많은 분들을 위해서요. 그래서 우리는 하버드 기록 보관소로 갔었고, 그곳에는 1794년에 하버드 학생이 그린  수채화 그림을 있었어요. 지금 하버드 광장에서 하버드 대학교의 초기 건물을 보고 있어요. 그리고 기술 덕분에 우리는 약 200년 전의 작은 수채화 그림을 가져와 로브 드라마 센터 무대를 장식했어요. 왼쪽에는 Holden Chapel, 오른쪽으로는 학부 기숙사 중 하나인 Hollis Hall, 강의실 건물 중 하나인 Harvard Hall과 1학년들과 Harvard 회장이 각각 거주하고 일을 하는 Massachusetts Hall이 있습니다.

CS50에 온 것을  환영합니다. 얼마 전은 아니지만 20년 전만 해도 같은 수업을 들었고, 여러분들도 알겠지만 CS50을 공부할 때 매우 생소한 분야에요. 그래서 저도 그 때 약간 겁을 먹었어요. 저는 저만의 편안한 위치에만에 머무르고, 정부에 대해 집중하고 공부할 것이라는 생각으로 길을 걷고 있었거든요. 그리고 그것은 내가 쇼핑을 하고 싶다는 마음이 들기 전까지 계속 CS50 클래스에 앉아 있게 했어요. CS50을 수강하면서 나는 숙제가 이렇게 재밌을 수 있다는 것을 깨닫게 되었어요.

컴퓨터 공학, 그리고 CS50은 그 자체로 프로그래밍에 관한 것이 아니라는 것을 알게 되었습니다. 이것은 문제 해결에 관한 것이에요. 따라서 컴퓨터 공학 분야 뿐만 아니라 예술학, 인문학, 사회 과학 등 그 이상의 분야에도 적용이 가능해요. 만약 CS50와 같은 수업을 듣는 것이 조금 불편하다면 거의 매년 CS50 수강생의 3분의 2가 컴퓨터학 과정을 수강한 적이 없다는 사실을 알아두세요.

만약 여러분들이 위, 아래, 왼쪽, 오른쪽을 보면, 여기에 합류한 많은 수강생들이 매우 비슷한 상황일 확률이 매우 높습니다. 여러분은 정말 좋은 동료입니다. CS50에서 궁극적으로 중요한 것이 강의 계획서 내용에 있으니, 다시 강조하겠습니다.



> *what ultimately matters in this course is not so much*
> *where you end up relative to your classmates* 
> *but where you end up relative to yourself when you began.* 
>
> *이 과정에서 궁극적으로 중요한 것은*
> *수강생들 간 비교로 끝이 아니라,*
> *시작했을 때의 나 자신과의 비교로 끝나는 것.*



현재 위치를 고려하고, 3개월 정도 후에 어디에 있을 것인지 고려하는 것이 궁극적으로 성공의 척도가 된다는 것 입니다. 그리고 그 끝에서 우리는 프로그램 프로그래밍을 시작할 것입니다. 여기 마리오 캐릭터가 피라미드를 오르는 슈퍼 마리오 게임의 이미지가 있습니다. 비록 ASCII 아트라고도 하는 텍스트이긴 하지만 이를 사용하여 이 게임의 일부를 다시 재생성할 것입니다. 우리는 수업의 2주 정도면 작업을 수행할 수 있을 것입니다. 이것은 여러분들이 직접 작성하는 첫 번째 프로그램이 될 것 입니다. 그리고 나중에 몇 주의 시간이 지나면서 프로그래밍 과제들이나 몇 가지의 문제들로 차차 나아갈 것입니다. 그리고 여러분들은 우리가 인터넷에서 실행되는 자체 웹 어플리케이션 CS50 Finance를 만들고 있을 것입니다. 이는 실시간으로 주가를 가져와 사용자가 로그인하고 주식 매매를 하기 위해 등록을 할 수 있도록 할 것입니다. 가상 화폐를 이용하는 것이죠. 몇 개월 후, 마리오 내 피라미드 구축에서부터 자신만의 웹 어플리케이션을 제작하는 것까지 등의 과정을 거쳐서 본 강의의 capstone 경험을 하게 될 것입니다. 그것은 여러분 자신만의 마지막 프로젝트가 될 것입니다.

그러면, 컴퓨터 공학이 정확하게는 무엇인가요? 먼저 첫 주에 우리가 생각해볼 것은 문제 해결이 정확의 무엇을 의미하는지 고려해보는 것입니다. 저는 이것이 컴퓨터 공학이고, 이것이 문제 해결이라고 하겠습니다. 여러분이 해결하기를 희망하는 문제를 입력(input)이라고 하고, 문제에 대한 해결책인 출력(output)에 관심이 있습니다. 그리고 입력(input)과 출력(output) 사이에는 이 검은 상자가 존재합니다. 그 검은 상자 안에는 일종의 마법이 있습니다. 그 마법은 결국 여러분들이 문제를 해결하기 위해 컴퓨터를 활용하고 강요할 수 있는 마법입니다. 궁극적으로 블랙 박스 내부에는 여러분이 직접 작성하는 코드가 될 것입니다. 하지만 이를 시작하기 위해서는 입력(input)과 출력(output)을 어떻게 표현해야 하는지에 대해 모두의 동의가 필요합니다. 말하자면 우리는 모두 공통된 언어를 사용해야 한다는 것이죠. 따라서 이러한 입력(input)이 어떻게 표현 될 것인지 동의해야 합니다.

그렇다면 일반적으로 정보는 어떻게 표현할 수 있을까요? 아마도 우리가 온라인이든 오프라인이든 첫 번째 수업에서 할 수 있는 가장 간단한 일은 출석을 확인하거나 방 안의 있는 사람들의 수를 세는 것입니다. 손가락을 통해 전통적인 방식으로 방 안에 있는 모든 사람을 표현합니다. 그리고 우리는 정보를 표현하는 방법은 당신의 손에 있는 아주 간단한 숫자로 요약됩니다. 물론 이 손만으로는 아주 높은 숫자를 셀 수 없겠죠. 실제로 우리가 하는 일에 대한 멋진 단어가 있습니다. 바로 단항 표기법(Unary notation)입니다. uno는 한 손가락이 위나 아래에 있다는 것을 의미합니다. 그리고 우리는 최대 다섯까지 셀 수 있습니다. 물론 다른 손을 이용하면 10까지 올라갈 수 있고, 조금은 어려워지기 시작합니다. 그러나 그것은 우리 모두가 어릴 때 상당히 보편적으로 정보를 표현하는 시스템입니다. 여러분과 저는 더 유용한 시스템을 사용하는 경향이 있습니다. 손에 있는 숫자이면서도 다른 종류에 숫자입니다. 이를 십진수(Decimal digits)라고 합니다. 십진법은 인간으로서 일반적으로 통용되는 10자리 숫자가 있다는 사실을 설명하는 멋진 방법입니다. 이 숫자는 0에서 9까지이며, 여러 숫자를 사용하여 0부터 9까지 뿐만 아니라 여러 자릿수를 사용하여 10, 11, 12,,, 그 이상 원하는 만큼 높게 까지도 할 수 있습니다. 하지만 컴퓨터는 우리와 같은 언어를 사용하지 않습니다. 그것들은 어떤 의미에서 우리 인간보다 훨씬 간단합니다. 어떤 의미에서는 컴퓨터의 언어가 더욱 복잡하거나 정교하고 확실히 더 빠르지만 말입니다. 결국에도 이것들은 모두 인간이 만든 장치에 불과합니다. 따라서 핵심은 상대적으로 매우 간단합니다. 

무슨 말을 하는지 잘 이해하지 못하더라도 적어도 이 말을 들어본 적이 있을 것입니다. 컴퓨터가 말할 수 있는 언어는 무엇입니까? 우리처럼 0에서 9까지 또는 십진수 체계를 사용하지 않는다면 컴퓨터는 대체 어떤 언어를 사용할까요? 이전에 CS 수업을 들었는지 여부와 관계없이 컴퓨터가 사용하는 시스템은 무엇일까요? 컴퓨터는 이진법(Binary) 체계를 이용합니다.

## Binary

컴퓨터는 0과 1로 구성된 이진법(Binary) 체계를 이용합니다. Binary에서 'bi'는 숫자 2를 의미하고 있죠. 이건 매우 힘이 됩니다. 왜냐하면 숫자들 중에 단 두 개의 숫자만 사용하는 아주 단순한 시스템이기 때문이죠. 하지만 여러분들이 만약 두 개의 숫자가 있다면 3, 4, 5 그리고 더 높은 숫자들은 어떻게 표현할까요? 마치 퇴보하는 것처럼 보일 것입니다. 하지만 실제로는 그렇지 않아요. 0과 1만을 사용하는 이진법 체계에서 우리는 버릴 수 없는 다른 이름이 있습니다. 바로 0과 1을 비트(Bits)라고 부르는 것이죠. 실제로 Bits는 Binary와 Digits에서 유래한 단어입니다. Binary는 두 가지 가능성을 암시하고, Digits는 화면에 나타나는 단순한 기호가 되는 것이죠. 그리고 Binary digits(이진수)는 비트(Bits)로 알려져 있습니다. 그렇게 컴퓨터는 비트라고 불리는 것을 이용해 이진법 체계를 말하는 것이죠.

그렇다면 컴퓨터의 이진법 체계 사용은 무엇을 의미하며, 그 이유는 뭘까요? 대체 왜 수십 년 전에 0에서 9까지 사용하는 컴퓨터 시스템을 발명하지 않고, 완전히 새로운 시스템을 고안하였을까요? 컴퓨터의 입력은 전기입니다. 아마도 우리가 노트북이나 데스크탑 컴퓨터, 휴대폰으로 매일매일 또는 이틀에 한번씩 하는 유일한 일은 콘센트가 꽂혀 있는지 확인하거나 충전하기 위해 연결하는 일입니다. 우리가 가진 장치에 할 수 있는 유일한 물리적 입력은 전기적 어떤 형태가 될 수 밖에 없겠죠. 그리고 우리는 전기가 무엇인지에 대한 자세히 알아갈 필요는 없어요. 전 그냥 충전하기 위에 장치로 흐르는 전자라고 생각합니다. 중요한 것은 우리가 사용하는 장치들에게도 물리적 입력이 있다는 것을 아는 것입니다. 따라서 우리가 전기를 이용한다면 정보를 표현하기 시작할 수 있을 것입니다. 예를 들어 설명하자면, 여기에 전구가 있습니다. 현재는 꺼져 있는 극장 무대등이죠. 하지만 우리가 콘센트를 꽂거나 스위치를 켜면 불이 켜질 수 있습니다. 전구를 사용해서 가장 설득력 있는 상황은 현재 전구가 꺼져 있지만 플러그를 꽂거나 스위치를 켜서 전기가 흐르도록 하자마자 불이 켜진다는 것이죠. 그리고 연결을 끊거나 스위치를 끄면 다시 불이 꺼지겠죠. 다시 연결하면 불은 켜집니다. 이 단순한 생각의 의미는 우리가 콘센트를 꽂고 뺌으로서 전구 하나와 같은 물리적 전구를 사용할 수 있다는 것이고, 그것으로 정보를 표현할 수 있다는 것입니다. 제가 방금 뭘 했죠? 저는 전구가 켜지거나 꺼짐을 표현했어요. 하지만 우리는 켜고 끄는 것을 0과 1이라고 부를 수 있습니다. 그리고 이것은 이진법 체계를 가져왔고 우리에게 컴퓨터를 제공하게 한 작은 생각의 기원이 되었습니다. 물리적 입력이 전기뿐이라면, 정보를 활용하고 추적하기 위해 그것을 사용해봅시다. 우리가 1을 나타내고 싶을 때 약간의 전기를 저장하고 대신에 0을 표현하고 싶다면 전기를 흘려보내겠습니다. 컴퓨터에 대한 입력이 매우 단순하기 때문에 현재 0과 1을 사용하게 되었습니다. 우리는 스스로 문제를 만든 것 같습니다. 전구 또는 스위치가 하나만 있고, 그것이 꺼져 있으면 0이 될 수 있고, 켜져 있다면 1이 될 수 있습니다. 1보다 높은 수는 어떻게 표현할 수 있을까요? 그 문제가 근본적으로 남아있게 됩니다. 물론 더 많은 전구를 사용할 수 있습니다. 그렇다면 세 개의 전구를 사용한다면 몇 까지 셀 수 있을까요?

현재 모든 전구가 꺼져있는 상태는 0을 표현합니다. 제가 첫번째 전구를 켜면 1을 표현한다고 하겠습니다. 두번째를 켜면 2, 세번째를 켜면 3이 되는 것이죠. 우리는 아직 충분히 똑똑하지는 않지만, 우리는 3보다 높게 셀 수 있습니다. 왜냐하면 왼쪽에서 오른쪽으로만 켜고 있기 때문입니다. 우리가 좀 더 영리하다면, 아마도 오른쪽에서 왼쪽으로 켜거나, 또는 다른 방향으로 바꾸는 일종의 재배치를 할 수 있습니다. 즉, 얼마나 많은 전구가 켜져 있는지 또는 얼마나 많은 손가락이 펴져있는지, 게다가 우리는 전구의 켜짐과 꺼짐의 패턴을 고려하기 시작했습니다. 그러니 그냥 세어보죠. 여기에서 이 전구 중 일부를 체계적으로 켜도록 하겠습니다. 

> ○○○ - 0 / ○○● - 1 / ○●○ - 2 / ○●● - 3 / ●○○ - 4 / ●○● - 5 / ●●○ - 6 / ●●● - 7 

이게 어떤 패턴을 가지고 있는지 잘 몰라도 괜찮습니다. 하지만 지금 총 8번의 독특한 패턴이 있다는 말을 받아들여야 합니다. 저는 다 꺼진 상태에서 시작해, 다 켜진 상태로 끝냈습니다. 그 과정에서 8가지의 숫자가 있었어요. 그렇다면 얼마나 높을 수 있을까요? 그건 여러분이 계산을 시작하는 숫자에 달려 있습니다. 그리고 우리가 해왔던 것처럼 컴퓨터 과학자들은 항상 이렇게 하고 있습니다. 컴퓨터 과학자들과 컴퓨터 프로그램은 일반적으로 0부터 세기 시작합니다. 모든 것이 꺼져있는 상황을 0이라고 부르는 것이 좋기 때문입니다. 그래서 우리가 0에서 세기를 시작하고, 8가지의 패턴을 가지고 있다고 하면 7까지 셀 수 있게 해줄 것입니다. 그렇기 때문에 우리가 세 개의 전구로 계산할 수 있는 가장 높은 수는 7입니다. 여러분들 중 36%가 정답을 맞췄습니다. 57%는 8이라고 대답을 했는데요. 만약 우리가 1부터 세기 시작한다고 가정하면 괜찮은 답입니다. 컴퓨터의 세계이기 때문에 우리는 일반적으로, 관습적으로 0부터 계산하기 시작할 것입니다. 그러나 가능성이 8가지 있다고 말한 것은 맞습니다.

전구 패턴을 통해 표현한 것은 아주 훌륭했습니다. 하지만 이제 실제 컴퓨터가 사용하는 0과 1에는 어떻게 접근할 수 있을까요? 컴퓨터 내부에 있는 것은 전구가 아닌 아주 작은 스위치입니다. 수백만 개의 작은 스위치들이 켜지거나 꺼지면서 0과 1이 될 수 있기 때문입니다. 이러한 스위치를 트랜지스터(Transistor)라고 부릅니다. 요즘 컴퓨터에는 다양한 패턴으로 켜고 끌 수 있는 트랜지스터들이 수백만 개가 있습니다. 따라서 이러한 스위치를 켜고 끌 수 있는 능력이 있다면, 그 스위치를 사용해서 만든 표현을 우리 모두가 동의할 수 있을까요? 우리는 그것들을 통해서 어떻게 표현을 할까요? 우리는 사실 그렇게 어렵게 생각할 필요도 없고, 어렸을 때 만들어진 편안한 루트를 지나쳐갈 필요도 없습니다. 우리가 잠시 0과 1이 아니라 여러분과 제가 사용하는 0에서 9까지의 십진법 전체를 고려해봅시다. 그 시스템은 어떻게 작동할까요? 여기 화면에 123이 있습니다. 여러분은 아마도 백이십삼이라는 숫자를 생각하고 있을텐데요. 정답은 아닙니다. 제가 화면에 보여드린 것은 상징의 패턴입니다. 123 또는 세 자리 숫자입니다. 우리는 아마 본능적으로 백이십삼이라고 말하고 있을 겁니다. 우리는 자라면서 제일 오른쪽 숫자가 일의 자리, 가운데가 십의 자리, 왼쪽이 백의 자리라는 것을 배우고 자랐습니다. 그렇다면 세 개의 기호 또는 숫자인 123에서 우리는 이 수학적 아이디어를 어떻게 얻을 수 있었을까요? 아마도 우리는 순식간에 계산을 했을 것입니다.

> 100	10  	1
>
> ###  1	2	3
>
> *100X**1** + 10X**2** + 1X**3***
> ***100 + 20 + 3***
> 123

우리 모두가 수학적 값으로 알고 있는 백이십삼입니다. 그래서 약간은 순환적인 주장이지만 우리가 123을 백이십삼으로 어떻게 얻었는지 다시금 알아보았습니다. 컴퓨터 세계에서 그들이 사용하는 시스템에서도 근본적으로 똑같습니다. 유일한 차이점은 컴퓨터는 0에서 9까지가 아닌 0과 1에만 접근할 수 있다는 것입니다. 그래서 우리가 지금 추상적으로 생각해본다면, 세 자리의 숫자 위에 몇의 자리라고 표기해야 할 지를 잠시 생각해봅시다.

사실 패턴이 있었는데, 이는 지수나 거듭 제곱과 관련이 있습니다. 맨 오른쪽은 10의 0 제곱인 1 입니다. 그렇게 10의 1 제곱 10, 10의 2 제곱 100이 되는 것이죠. 이런 식의 표현에서 흥미로운 점은 10이라는 숫자가 관련되어 있다는 점입니다. 0에서 9까지 10가지 숫자가 있으므로, 밑수에 10을 사용하는 것입니다. 이제 여러분은 컴퓨터가 사용하는 이진 시스템에서 0과 1의 두 자리만 있다는 것을 고려하면 더 앞선 이해가 가능할 것입니다.

우리는 여전히 1의 자리를 가지고 있습니다. 왜냐하면 2의 0 제곱은 1이기 때문이죠. 그리고 2의 1 제곱, 2의 2 제곱 등으로 나아갑니다. 물론 컴퓨터가 사용하는 이진법 체계에서 수학을 한다면 일의 자리, 이의 자리, 사의 자리 등으로 될 수 있을 것입니다. 이제 다른 기본 시스템에 대해서 생각해야하지만 이제 더 적절하게 계산을 시작할 수 있습니다. 이제 우리는 전구라는 은유에서 벗어나 모든 전구가 꺼져 있으면 이를 숫자 0으로 생각할 수 있습니다. 그리고 그것은 000인 기호 또는 숫자의 패턴이 됩니다. 여러분이 오늘 이후에 하게 될 암산은 분명히 `4X0 + 2X0 + 1X0`이 될 것입니다. 물론 십진수로 0입니다. 그럼 컴퓨터가 1은 어떻게 표현할까요. 그건 가장 오른쪽의 비트를 0에서 1로 바꾸면 되겠죠. 아까 비유했던 가장 오른쪽 전구를 밝히는 것처럼 말이죠. 2는 이진수로 010이 될 것입니다. 3은 011로 두 개의 스위치를 켜고 있습니다. 왜냐하면 저는 2와 1의 합으로 3을 표현해야 하기 때문이죠. 다음을으로 4를 세기 위해서는 100이 됩니다. 5는 101, 6은 110, 7은 111이 됩니다. 이는 각각 0 또는 1이 될 수 있는 세 자리의 비트들을 사용하는 것처럼 보일 것입니다. 총 8가지 방법으로 비트들을 바꿀 수 있습니다.  첫 번째 비트에 대한 두 가지 가능성과 두 번째 비트에 대한 두 가지 가능성, 마지막 세 번째 비트에 대한 두 가지 가능성들로 인해 우리에게는 8가지의 가능성이 생겼습니다. 하지만 여기 수학에서는 0부터 세기 시작하는 관습에 따라 우리는 총 7까지만 셀 수 있습니다. 

이 무대 처럼 많은 전구를 가질 수 있다고 합시다. 수많은 전구가 무대를 장식하고 있습니다. 그럼 질문하겠습니다. 이 전구가 표현하는 숫자는 십진수로 몇일까요?

> ○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○●●○●○●
>
> 정답은 50입니다. 

다른 모든 전구들을 이용하면 얼마나 높은 숫자를 셀 수 있을 지 상상해보세요. 우리는 전기 이야기로 시작해서, 숫자로 넘어가 십진수와 이진수로 표현을 했습니다. 하지만 우리는 스위치나 전구만을 가지고 0과 1을 생각할 수 있었기에, 컴퓨터가 할 수 있는 일은 계산 뿐인 것처럼 보입니다. 즉, 계산기와 같이 보입니다. 사실 초기에는 컴퓨터는 계산 용도로 설계된 것이었습니다. 수학 계산을 정말 용이하게 해주었습니다. 하지만 현재 사용하고 있는 컴퓨터는 우리가 휴대폰, 노트북, 컴퓨터에서 매일 사용하는 것은 보다 복잡합니다.

## ASCII

컴퓨터가 어떻게 숫자를 넘어서 알파벳의 글자를 표현할 수 있게 되었을까요? 우리가 사용 가능한 것이 스위치 뿐이라면 말이죠. 특정 알파벳 문자에 이진수를 할당하면 됩니다. 그것이 우리의 유일한 방법이겠죠.

우리가 스위치, 전구, 비트를 바꾸는 것 밖에 하지 못한다면, 모두가 같은 방식으로 문자를 표현하는 방법에 동의하면 가능해집니다.

대문자 A에 1이라는 숫자를 부여하게 되면, 전구 하나를 켜거나 이진수 1로 A를 표현할 수 있게 됩니다. 대문자 B는 2라는 숫자를 사용할 수 있겠죠. C는 3이 되겠네요. 그렇게 우리는 문자에 번호를 매기는 것에 동의하면 됩니다. 인간은 정확히 그렇게 했습니다. 

실제로 대문자 A는 65라는 숫자로 표현되고 있습니다. 비트 형태로 보면 01000001로 나타납니다. 이제 컴퓨터가 수행할 작업은 사용중인 프로그램의 유형 속 맥락에서 파악하는 것입니다. 프로그램은 하드웨어의 내부를 궤뚫어보고 십진수 65를 나타내는 패턴을 인식합니다. 그리고 계산기나 EXCEL과 같은 맥락에서는 65를 나타내게 되며, 문자메시지나 이메일, 여러 SNS에를 이용하는 맥락에서는 A를 표현하게 되는 것입니다. 

여기서 65를 A로, 66을 B로 매핑하는 시스템을 미국 표준인  ASCII 코드라고 합니다. 정보 교환을 위한 코드로 잘 정의된 매핑이 존재하게 되었다는 것을 의미합니다. 여기에는 구두점, 소문자에 대한 전체 매핑까지 있습니다.

`72 73 33`을 포함하는 문자 메시지를 받았다고 가정해봅시다. 이는 HI!로 보여질 수 있습니다. ASCII 코드 차트를 확인할면 알 수 있습니다. 우리가 사용하는 컴퓨터와 휴대폰에서는 이를 본질적으로 알고 있습니다.

일반적으로 요즘 컴퓨터는 8비트를 사용하여 각 문자를 나타냅니다. ASCII가 처음 나왔을 때는 공간이 비쌌기 때문에 7비트를 사용했습니다. 즉, HI!를 표현하기 위해서는 총 24비트를 보내거나 받고 있다는 것입니다.

이제 비트는 매우 유용한 측정 단위가 아닙니다. 일반적으로 너무나도 작기 때문이죠. 0 또는 1 그 뿐이죠. 따라서 각각의 8비트 패턴은 바이트라고 표현됩니다. 우리는 바이트라는 단어를 사용하고 있습니다. 실제로 요즘 파일 크기에 대해 이야기할 때 메가바이트, 기가바이트와 같이 말이죠. 바이트는 간단히 말해서 8개로 구성된 0과 1의 패턴입니다. 따라서 실제로 사용할 수 있는 전구가 64개 정도라면 8바이트로 8글자를 표현할 수 있게 되는 것이죠. 물론 ASCII 코드는 정보 교환을 위한 미준 표준 코드이기 때문에 편향되어있고 제한되어있습니다. 8비트로 표현할 수 있는 글자는 256개입니다. 2를 8번 곱한 가능성이죠.

256개의 가능성이 충분하지 않은 이유, ASCII에서 놓치고 있는 것은 악센트 부호가 있는 문자, 알파벳 외의 일부 언어를 빠뜨리고 있다는 것입니다. 우리 인간이 인쇄물로 의사 소통하는 데 사용하는 더 많은 기호들이 있습니다. 그리고 요즘에는 우리 인간이 말하고 싶은 다른 것들이 있다는 것을 보여주고 있습니다. 이모지, 이모티콘과 같은 것들 말이죠. 이모지는 사진이나 그림처럼 보입니다. 기술적으로는 컴퓨터에서 구현되는 방식입니다. 즉, 이것 또한 0과 1의 패턴이라는 것이죠.

## Unicode

이는 세계가 수년에 걸쳐 ASCII에서 전환되었기 때문에 가능해졌습니다. 문자를 표현하기 위해서 7비트, 그리고 8비트, 16비트, 24 또는 32비트를 사용하는 것입니다.

요즘에는 인간이 만든 유니코드라는 시스템이 있습니다. 영어 뿐만 아니라 모든 인간 언어를 지원합니다. 게다가 이모지까지 표현할 수 있게 되었습니다. 여기 기쁨의 눈물을 흘리는 이모지가 있습니다. 우리는 문자메시지, 이메일, SNS에서 키보드의 키 하나로 표현할 수 있지만 그 안에는 우리가 보지 못하는 십진수 128,514가 있습니다.

지금까지 우리는 전기로 시작해서 숫자를 표현하고, 이제 글자를 표현할 수 있게 되었고, 심지어는 이모지까지도 표현할 수 있게 되었습니다.

## RGB

여기서 이모지는 본질적으로 그림으로 볼 수 있겠죠. 그럼 컴퓨터는 어떻게 색상을 표현하는가에 대해 궁금해지게 됩니다. 기쁨의 눈물을 흘리는 이모지의 얼굴에는 노란색이 많이 포함되어 있습니다. 마음대로 사용할 수 있는 것이 0과 1의 비트에 불과하다면 노란색을 포함한 다양한 색상들이 어떻게 표현될까 고민해봅시다.

다른 색상에 숫자를 할당하고 우리 모두는 그 매핑이 실제로 어떻게 될 지에 대해 동의해야 합니다. 그래서 이를 수행하는 다른 방법이 있습니다. 디지털 방식의 예술 작업을 해본 사람이라면 빨강, 녹색, 파랑의 약어인 RGB에 익숙할 것입니다. 그러나 다른 약어와 다른 방법도 존재합니다.

RGB는 인간이 몇 년 전에 생각해 낸 시스템입니다. 실제로 RGB는 약간의 적색, 녹색, 청색의 빛을 혼합하여 다양한 색을 구현해낼 수 있습니다. 그렇다면 적색, 녹색, 청색이 가지고 있는 각각의 양을 어떻게 표현할 수 있을까요?

우리가 다시 72, 73, 33의 비트 패턴을 받는다고 가정해봅시다. 텍스트 맥락에서는 HI!가 표현되었지만 이번에는 이메일, 문자메시지의 맥락이 아닙니다. 이 비트 패턴은 Photoshop, 인스타그램과 같은 이미지 중심의 모든 맥락에 있습니다. 그리고 앞서 발견한 것처럼 총 숫자는 8비트로 표현할 수 있는 가능성의 수는 256입니다. 0부터 계산을 작하면 나타낼 수 있는 가장 높은 값은 255입니다. 그래서 이것은 세 숫자 각각 0에서 255사이의 숫자를 갖게 됩니다. 72, 73, 33은 해당 숫자 정도의 적색, 녹색, 청색이 되는 것입니다. 이 세 가지의 양의 색상을 결합하면 8비트와 8비트와 8비트의 합인 총 24비트를 사용하여, 노란색의 점을 만들어내게 됩니다. 그래서 이모지가 화면에 실제로 표시될 때 컴퓨터 해석의 결과로서 나타나게 됩니다.

128,514라는 숫자로 기쁨의 눈물을 흘리는 이모지를 표현하는 것은 단순히 아는 것에 불과합니다. 정보를 화면에 표시할 때에는 이제 컴퓨터는 다른 패턴의 비트를 사용하게 됩니다. 그것은 화면의 점 색상을 제어합니다. 요즘 우리가 보는 TV나 컴퓨터 화면에서의 점들을 픽셀이라고 합니다. 색상을 나타내는 작은 사각형이죠. 기쁨의 눈물을 흘리는 이모지를 계속해서 확대하다보면 우리는 픽셀이라고 부르는 것을 실제로 볼 수 있습니다. 사진의 크기를 조정하거나 편집할 때마다 충분한 해상도가 있습니다. 이미지의 해상도는 수평과 수직으로 구분된 픽셀, 즉 점의 개수입니다. 따라서 이미지를 실제로 확대하게 되면 결국 해당 픽셀이 표시되는 것이죠. 그리고 이것은 확대된 이모지에서도 엄청나게 많은 수의 노란색, 검은색과 회색, 갈색 등의 픽셀들로 다채로운 이미지를 구성하게 됩니다.

픽셀은 24비트(3바이트)를 사용하고 있습니다. 이제 상상할 수 있습니다. 축소하고 보게 되면 이미지인 수백, 수천개의 픽셀들이 모두 3바이트이면 이것은 우리가 찍은 사진이나 다운로드한 이미지들이 일반적으로 바이트가 아니라 킬로바이트  단위로 측정되는 이유가 됩니다. 비디오 파일이라면 수십억 바이트 또는 기가 바이트로 나타나게 될 수도 있습니다. 이것들은 후드 아래에서 일어나는 것들 입니다. 우리는 이런 방식으로 정보를 표현하고 있습니다.

모든 이미지가 픽셀 격자 형태로 구성되어 있습니다. 점들이 각각의 색상을 나타내며, 많은 점들이 있기 때문이죠. 그럼 컴퓨터가 비디오 파일을 나타내는 방법은 어떻게 될 수 있을까요? 이는 개별 픽셀의 RGB를 빠르게 변경하는 방식으로 표현될 수 있습니다. 그리고 그것은 화면에 움직임이 있는 것처럼 보여질 수 있습니다.

플립북이라는 형태와 유사합니다. 플립북은 우리가 어릴적 직접 만들어봤거나, 적어도 한번에는 어딘가에서 봤을 것 입니다. 각각의 페이지는 비슷하지만 약간씩 다릅니다. 이를 통해 애니메이션을 만들거나 실제로 비디오를 만들 수 있습니다. 즉, 비디오는 실제로 이미지들의 전체 시퀀스라는 것입니다. 특정한 속도로 화면을 가로질러 날아가는 이 방식이 바로 오늘날 우리가 알고 있는 비디오 파일을 제공하는 것입니다.

이러한 고민으로 더 많은 것들을 생각해볼 수 있습니다. 음악은 어떻게 표현될 수 있을지에 대한 것들을 말이죠. 사실 음악은 좀 다른 방식으로 표현될 수 있습니다. 예를 들어 피아노를 치면, A에서 G까지 음표가 있다는 것을 알 수 있습니다. 그 안에는 샵과 플랫 등도 있습니다. 게다가 어떤 음표에는 숫자가 필요할 수도 있습니다. 이미지가 여러 숫자를 사용하여 점을 나타내는 것처럼 숫자를 사용해 노래의 음표를 나타낼 수 있습니다. 그리고 그 음표의 지속 시간을 나타내는 또 다른 숫자들이 존재합니다. 음악은 컴퓨터 세계에서 양자화될 수 있습니다. 정보의 작은 조각으로 말이죠. 

우리가 무언가를 표현하기 위해, 0과 1의 조합으로 만들고 그것들에 동의하는 것이 바로 모든 것들이 작동하는 방식입니다. 그리고 JPEG, PNG와 Word Doc, Excel과 같은 파일 형식들 또는 확장자들은 0과 1의 패턴을 파일에 저장하는 방법들에 동의하는 집합이라 볼 수 있습니다. 그 집합들은 화면에 비춰지기 위해, 해석을 위해, 0과 1의 패턴이 컴퓨터에 로드될 때 그 패턴이 무엇을 나타내는 지 알고 있습니다. 

## Algorithms

우리가 동의하는 한 전 세계에서는 정보가 어떻게 표현이 되는지를 알게 됩니다. 이제 우리는 입력(Input)을 해보려 합니다. 문제 입력을 통해 문제를 해결하고 결과물(Output)이 얻어지기를 원합니다. 따라서 문제 해결에 남아있는 것은, 또는 컴퓨터공학에 남아있는 것은 Input과 Output 사이에 있는 블랙박스의 내부를 살펴보고, 숫자, 문자, 이미지, 비디오, 오디오 등을 Input하는 방법에 대해서 고민해보는 것이고, 그것들을 실제 솔루션으로 변환하는 것입니다. 그리고 일반적으로 이러한 블랙박스 내부를 알고리즘으로 설명합니다. 

알고리즘은 문제 해결을 위한 단계적 지시입니다. 알고리즘은 컴퓨터가 포함될 필요가 없습니다. 인간은 다른 사람 지시에 따라 알고리즘을 실행할 수 있습니다. 만약 레시피에 근간하여 무언가를 준비하고 있다면 알고리즘을 단계별로 실행하고 있는 것 입니다. 하지만 수많은 레시피와는 달리, 그리고 인간이 서로에게 주는 지시와는 달리, 컴퓨터에게 하는 지시는 모호함이라는 공간이 있을 수 없습니다. 기계에 의해 구현되는 컴퓨터 알고리즘은 올바른 Output을 얻기 위해서 정확하고 또 정확해야 합니다. 왜냐하면 인간과는 달리 line 사이를 읽고 무슨 뜻인지 이해하기 때문입니다. 말 그대로 우리를 지시한 곳으로 데려다주는 역할만을 하는 것입니다.

컴퓨터 프로그래밍을 하는 경우, 즉 알고리즘을 번역할 때에는 컴퓨터가 이해할 수 있는 언어로 단계별 지시를 내리기 때문에 컴퓨터가 사용자의 의도를 잘 못 해석하지 않도록 해야합니다.  따라서 그러한 알고리즘 중 하나를 고려해보겠습니다. iOS나 Android 등 모든 휴대폰에는 연락처 App이 있습니다. 그리고 그 연락처 App은 거의 모든 가족과 동료들, 친구들을 저장하고 있겠죠. 아마도 알파벳(가나다) 순으로 정렬이 되어있을 것입니다. 하지만 이것의 옛 버전은 종이 형태로 만들어졌습니다. 전화번호부는 연락처 App과 같은 아이디어로 구성되어 있습니다. 훨씬 크고 훨씬 많이 인쇄되어 있지만 이 둘은 본질적으로 같은 것입니다. 일반적인 전화번호부에는 수많은 이름과 전화번호가 있습니다.

### Find David

일반적인 연락처 App처럼 알파벳(가나다) 순으로 정렬이 되어있습니다. 우리가 문제를 풀고 싶다고 가정해봅시다. 그 문제에 대한 입력은 전화번호부 뿐만 아니라 번호를 찾을 사람의 이름까지 포함합니다. 예를 들어 제 이름을 말입니다.

제 전화번호를 찾고 싶은 경우에는 이 전화번호부를 펼 수 있습니다. 예를 들어 David를 찾기 시작합니다. 전화번호부가 이름으로 정렬되었다는 것을 가정해봅시다. 첫 페이지에 David가 표시되지 않으므로 두 번째 페이지로 이동합니다. 그곳에서도 찾을 수 없다는 세 번째 페이지로 이동합니다. 그래서 한 번에 한 페이지 씩 이름을 찾고 차례로 번호를 확인합니다. 정확성이 중요하다면 먼저 이 질문을 하겠습니다. 이 알고리즘은 페이지를 단계적으로 넘기고 David를 올바르게 찾고 있는 걸까요? 네, 이 알고리즘은 실제로 올바르게 작동하고 있습니다. 하지만 이것은 매우 느립니다. 우리가 앞으로 고려해야 할 아이디어 중 하나는 정확성도 있지만 효율성도 존재합니다. 알고리즘이 얼마나 잘 설계(Design) 되었는가? 하는 것 말입니다. 이 알고리즘의 작업은 엄청나게 지루하고 느립니다.

물론 우리는 더 잘할 수 있습니다. 한 번에 한 페이지를 찾는 대신에 한 번에 두 페이지 씩 검색할 수 있습니다. 과연 이 알고리즘은 올바르게 찾고 있는 것일까요? 저는 이 방법이 효율적인 설계라고 주장합니다. 왜냐하면 문제를 두 배는 더 빨리 해결할 수 있기 때문이죠. 하지만 페이지에서 내 이름을 건너 뛸 가능성이 존재합니다. 그럼 이 방법을 해결할 수 있을까요? 전체 알고리즘을 그냥 버려야 할까요? 아니면 이 문제를 고칠 수 있을까요? 여기서 속도 향상이라는 좋은 아이디어를 완전히 버릴 필요는 없다고 생각합니다. 이 알고리즘은 두 배나 빠르게 작동할 수 있습니다. 하지만 너무 빠르다면 D가 아닌 E 섹션에 도달할 수도 있습니다. 그렇다면 다시 두 페이지를 뒤로 이동해야합니다. 그럼 두 페이지 사이에 David가 있다는 것을 알 수 있게 됩니다. 이름을 건너뛸 가능성은 50%이지만, 뒤로 이동하는 것과 같이 우리는 회복할 수 있습니다. 스스로에게 질문을 합니다. `잠깐만, 놓친 것 같아.`와 같이 말이죠. 그래서 우리는 전반적인 속도 향상을 얻을 수 있습니다. 하지만 최소한 그런 종류의 실수나 버그를 고쳐야 합니다.  버그는 일반적으로 알고리즘에서 프로그램의 실수를 의미합니다. 그러나 솔직히 우리 중 누구도 두 페이지 씩 검색하고 뒤로 이동하는 행동을 하지 않을 것입니다.

실제로 전화번호부에서 누군가를 검색할 때에는 우리는 휴대폰과 마찬가지로 맨 앞에서부터 시작하지 않습니다. 그리고 컴퓨터는 더 직관적으로 할 수 있는 일들을 정확하게 수행합니다. 우리는 아마도 대략 중간으로 갈 것입니다. 맨 앞 글자가 D이기 때문에 조금은 왼쪽으로 치우쳐질 수 있습니다. 만약 M 섹션을 폈다면, 우리가 정확하게 알 수 있는 것은 책의 오른쪽은 살펴볼 필요가 없다는 것입니다. 말 그대로 문제의 절반을 버릴 수 있게 되는 것입니다.  그렇다면 왼쪽 절반만 남아있는 책에서 우리는 한 번 더 똑같은 알고리즘을 사용할 수 있게 됩니다. 같은 논리를 적용해, 절반만 남은 책의 중간부분을 펴게된다면 또 다시 절반을 버릴 수 있게 되는 것입니다. 우리는 지금 1,000페이지에서 500페이지로, 500페이지에서 250페이지로 이동했습니다. 이러한 방법은 1,000페이지에서 999, 998,...로 가는 것보다 훨씬 빠릅니다. 심지어 1,000페이지에서 998, 996,...으로 가는 것보다도 훨씬 빠릅니다. 세번째 알고리즘은 정확하기까지 합니다. 첫번째는 확실히 정확했고, 두번째는 버그 수정이 필요하겠지만 첫번째보다는 훨씬 효율적입니다.

## Solving Problems Efficiently

만약 다음 연도의 전화번호부가 어떠한 이유에 의해서 두 배나 두꺼워졌다면 어떨까요? 세번째 알고리즘에서는 단 하나의 단계가 추가되는 것입니다. 그리고 그것은 문제해결의 시간에 아주 미미한 차이만을 만들 것입니다. 우리는 세번째 알고리즘을 사용하면 문제에서 훨씬 더 큰 문제를 해결할 수 있습니다. 그리고 이것은 컴퓨터공학과 프로그래밍은 궁긍적으로 같습니다. 강의에서 얻은 아이디어를 활용하는 것은 일상 생활에서도 적용 가능하다는 것입니다. 하지만 여러분은 알고리즘을 이용해 문제를 어떻게 표현하는지, 어떻게 그것들을 컴퓨터 음성으로 번역할 것인지 생각할 필요는 없습니다. 알고리즘에 대해 생각하는 것의 시작은 정확성 뿐만 아니라 얼마나 잘 설계되었는지에 있습니다. 

## Pseudocode

프로그래밍에서는 우리는 알고리즘이라는 것을 코드로 변환할 필요가 있습니다. 이를 의사 코드(Pseudocode)라고 합니다. 잠시 후에는 그래픽이지만 실제 프로그래밍 언어에 초점을 맞출 것 입니다. 하지만 지금은 코드의 구조 또는 유용할 기초적인 생각들만을 고려해봅시다. 그리고 어떤 말이나 어떤 글이든 구현된 알고리즘과 같은 역할을 하는 의사 코드(Pseudocode)가 되는 것입니다. 핵심은 모호함이 없도록 정확해야 한다는 것에 있습니다.

```pseudocode
1	"Pick up" phone book
2	"Open to" middle of phone book
3	"Look at" page
4	[If] (person is on page)
5		"Call" person
6	[Else if] (person is earlier in book)
7 		"Open to" middle of left half of book
8		{Go back to line 3}
9	[Else if] (person is later in book)
10		"Open to" middle of right half of book
11		{GO back to line 3}
12	[Else]
13		"Quit"
```

이 코드 중에서 강의에서 계속 보게 될 코드를 보게 되면, `" "`으로 강조 표시된 것은 동작입니다. 이는 일반적으로 프로그래밍에서 함수로써 사용됩니다. 함수는 컴퓨터가 무언가를 하도록 하는 동작 또는 동사의 진술입니다.

다음으로 `[ ]`으로 강조 표시되는 것은 조건 또는 분기라고 하는 것입니다.  이것은 일종의 갈림길이라고 볼 수 있습니다. 여러분은 이것을 할 수도, 저것을 할 수도 있으며, 아니면 다른 일을 할 수도 있습니다. 그리고 한 가지 결정을 내릴 수 있습니다. 많은 조건들은 논리적으로 의미가 있습니다.

그럼 어떤 갈림길을 가야할 지 어떻게 결정할 수 있을까요? 이를 위해서는 `( )`으로 강조된 부울 표현식(Bool 또는 Boolean)이 필요합니다. 부울 표현식은 질문일 뿐입니다. 대답을 예, 아니오 또는 참, 거짓으로 결정 짓는 질문입니다. 즉, 1 또는 0으로 결정하는 질문입니다. 부울 표현식은 동일한 목적이 있습니다. 흑과 백으로 정확히 구분하여 대답하는 것을 상상할 수 있는 질문이라면 이것이 우리에게 부울 표현식이 될 수 있습니다.

그리고 마지막으로 `{ }`으로 표시된 것들이 있습니다. 이것은 우리가 루프 또는 사이클이라고 부르는 것을 유도하는 것입니다. 프로그래밍 구조 또는 알고리즘의 원리입니다. 당신이 무언가를 몇 번이고 반복하게 해서 100줄 이상의 알고리즘을 쓸 필요 없이 13줄의 알고리즘만을 작성하고 일부를 반복해서 재사용할 수 있게 합니다. 

그리고 이제부터는 우리는 실제 프로그래밍 언어를 시작할 것입니다. 그 언어는 여러분이 최근에 사용했을 수도 있고, 어릴 적 사용했을 수도 있는 스크래치(Scratch)라고 알려진 그래픽 프로그래밍 언어입니다. 스크래치는 프로그래밍에 근간이 되는 많은 것들을 표현합니다. 우리는 단 일주일만에 더 고전 방식의 언어인 C를 습득하기 위한 과도기로 스크래치를 이용할 것입니다. C언어는 완전히 텍스트 및 키보드 기반의 언어입니다. 하지만 우리는 CS50에서 배우는 모든 언어에서 함수, 조건, 부울 표현식, 루프, 변수, 스레드, 이벤트 등을 전부 보게 될 것입니다. 변수, 스레드, 이벤트 등은 잠시 후에 배우게 될 것입니다. 수학의 x, y, z와는 좀 다른 변수들, 컴퓨터의 행동을 허락하여 한 번에 여러 가지 기능을 하게 하는 스레드, 이벤트 및 기타 기능을 배우게 될 것입니다.

여기에서는 의사 코드를 실제 코드로 전환할 것입니다. 여기 화면에 보이는 것은 C라는 언어입니다.

```c
#include <studio.h>
int main(void)
{
    printf("hello, world\n");
}
```

이것은 아까 말했듯이 고전적인 텍스트 기반, 키보드 기반의 언어입니다. 그러나 이 언어는 약간 수수께끼 같습니다. 언뜻 보면 여러분은 왜 해시태그, 꺽쇠, 괄호, 중괄호, 세미콜론, 따옴표 등이 있는지 궁금할 것입니다. 이럴수가! 화면에 표시되는 내용에 구문이 너무나 많습니다. 하지만 우리는 이 프로그램이 무엇을 하는지 짐작할 수 있습니다. 네, 단순히 hello, world를 출력합니다. 이런, 우리는 컴퓨터에 이 명령을 내리기 위해 모든 구문과 키 입력을 해야 했습니다.

## Scratch

이것과 대조적인 것이 스크래치 입니다. 우리는 훨씬 친근하고 더 그래픽적인 스크래치를 배울 것입니다. 이는 더 다양한 아이디어들을 탐색할 수 있게 하며, 더 복잡하고 전통적인 언어들을 배우기 위한 뼈대가 될 것입니다. 그렇다고해서 꺽쇠, 괄호, 중괄호, 세미콜론과 같은 구문을 걱정할 필요가 없습니다. 이제 스크래치를 소개하겠습니다. 스크래치는 scratch.mit.edu에서 직접 해볼 수 있습니다. web 기반이지만 오프라인 버전 또한 존재합니다.

인터페이스의 버튼을 통해 프로젝트를 시작하면 우측 상단에 첫 번째 스크래치가 표시됩니다. 프로그램의 이름을 딴 고양이는 여러분이 위, 아래, 왼쪽, 오른쪽 이동시킬 수 있는 작은 직사각형의 세계에 살고 있습니다. 하지만 고양이는 여러 다른 캐릭터 또는 우리가 스프라이트라고 부르는 것은 시각적 표현으로 변형될 수 있습니다.

좌측에는 스크래치와 함께 제공되는 모든 빌링 블록이 있습니다. 사용 가능한 모든 프로그래밍 구조가 퍼즐 조각의 형태로 나타나 있고, 여러분은 모든 퍼즐 조각들이 색상과 설명에 따라 분류되어 있다는 것을 눈치챌 수 있을 것입니다. 그것은 그들이 하는 일을 알려줍니다. 다양한 퍼즐 조각들 속으로 들어가 살펴보는 것이 오늘의 목표가 아니라 할 수 있는 기본적인 아이디어들을 강조하기 위한 것을 목표로 하고 있습니다.

그리고 여기 화면 중앙을 통해 이러한 아이디어를 탐색할 것입니다. 잠시 후 우리는 퍼즐 조각들을 이 넓은 화면 중앙으로 드래그 앤 드롭을 시작할 수 있을 것입니다. 그리고 그것들을 논리적으로 타당하다면 서로 맞물릴 것입니다. 마지막으로 대부분의 정교한 프로그램들의 경우, 우리는 실제로 더 많은 캐릭터 또는 스프라이트를 만들 수 있습니다. 그리고 실제로 화면에도 많은 상호 작용이 있습니다.

## Hello, World

실제 scratch.mit.edu로 이동하겠습니다. 그리고 Scratch의 인터페이스로 들어가기 위해 Create를 클릭하겠습니다. 그리고 계속해서 프로그램 작성을 시작하게 됩니다. 첫 번째로 시도해볼 것은 노란색의 퍼즐 조각 같은 것인데요. Events 카테고리이며. 녹색 깃발을 클릭하면 호출이 됩니다. 우측 상단의 스크래치의 무대를 보면 상단 왼쪽에는 Go를 의미하는 녹색 깃발이 있습니다. 그리고 그 옆에 빨간색 정지 신호는 Stop을 의미합니다. 만약 녹색 깃발을 클릭했을 때 어떤 일이 일어나기를 바라면, 녹색 깃발이 있는 노란색 퍼즐 조작부터 시작합니다.

이제 Looks 카테고리를 살펴보죠. Looks 카테고리에는 블록이 많이 있습니다. 여기서 가장 간단한 블럭을 선택해 Hello, World를 작성하겠습니다. 다시 스크래치 무대로 이동으로 해서 녹색 깃발을 클릭하겠습니다. 그러면 Hello, World가 출력되는 것을 볼 수 있습니다. 이것이 여러분과 제가 스크래치를 통해 제작한 첫번째 프로그램입니다. 하지만 이것은 그다지 흥미로워 보이는 것은 아닙니다. 물론 처음이기에 흥미롭긴 하지만 몇 번이고 플레이하고 싶을 정도는 아닙니다.

## Variables

우리는 이러한 빌딩 블록을 계층화하여 이것을 훨씬 더 활동적으로 만들 수 있습니다. 전화번호부를 검색하는 것과 같은 프로그램에 여러 단계가 있듯이 말입니다. 일단 이 프로그램을 정지시키고 조금 더 살펴보겠습니다. 이번에는 Sensing이라는 파란색 카테고리로 이동하겠습니다. 여기서는 `ask What's your name? and wait` 블럭이 보입니다. 여기서 하얀 부분의 질문은 직접 수정할 수 있다는 것을 의미합니다. 하지만 지금은 그 질문 그대로 사용하겠습니다. 

우선 기존에 있던 블럭을 제거하고, 다시 초록 깃발이 있는 노란 블럭을 쌓겠습니다. 그리고 그 파란색 블럭을 쌓겠습니다.이 파란색 블럭은 좀 특이합니다. 왜냐하면 변수라고 하는 것이 함께 제공되기 때문인데요. 이 질문 퍼즐 조작은 말 그대로 사람들에게 질문을 할 것입니다. 그리고 그 질문에 대한 답을 변수에 저장할 것입니다. 여기에 있는 파란 타원형(`answer`)을 변수라고 합니다. 수학에서의 x, y, z와 마찬가지 입니다. 다시 Looks 카테고리로 가서 `say Hello` 블럭을 붙이고 인사를 하려 합니다. 하지만 이번에는 다릅니다. 블럭을 하나 더 붙이고, `Hello`를 지웁니다. 그리고 `Sensing`으로 돌아가서 대답을 끌어다 놓을 것입니다.

이를 실행하면 스크래치는 이름을 묻고, 저는 David라 대답하겠습니다. 하지만 스크래치는 Hello를 하지 않고, David를 출력하는 것처럼 보입니다. 스크래치가 인사를 하고 이름을 말하지만, 너무 빠르게 지나가서 이름만 나타난 것처럼 보이는 것입니다. 그래서 임의의 일시 중지를 할 수 있는 대기 블록을 찾아야 합니다. Operations 카테고리 내에는 수학과 관련된 내용들이 많이 있습니다. 그리고 언어와 관련된 것들도 있습니다. 저는 여기서 join 블럭을 이용해 `Hello`와 `answer` 를 함께 둘 것입니다. 

프로그램은 점점 흥미로워지고 있습니다. 하지만 패러다임은 이전과 다르지 않습니다. 사실 우리가 방금 한 모든 것들은 문제를 해결하기 위한 컴퓨터 과학적 측면에서의 정신적 모델에 부합하고 있습니다. 입력과 출력이 목표이고 그 사이의 알고리즘이 있습니다. 우리가 처음 시도했던 input은 Hello, World였고, 이 알고리즘은 say라는 스크래치의 함수로 구현되었습니다. 함수는 컴퓨터 알고리즘의 구현입니다. 그리고 output으로 고양이가 Hello, World를 말하는 것입니다. 그리고 두번째로 시도하게 된 내용에서도 마찬가지입니다. 여기서의 블록은 매우 흥미롭습니다. 왜냐하면 say 블록의 흰색 타원형 공간에 다른 퍼즐 조각이 있습니다. 그리고 그 위에 퍼즐 조각이 두 개 더 있습니다. 여기서 멋진 점은 함수를 프로그래밍 할 때, 한 기능의 출력이 다른 함수에서 입력이 되도록 할 수 있다는 것입니다.

즉, 우리는 입력을 전달하고 출력을 얻고, 출력을 입력으로 만들고 계속 반복되는 것. 이것이 궁극적으로 프로그램이라는 것이 의미하는 패러다임입니다. 